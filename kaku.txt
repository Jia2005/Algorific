import React, { useState, useEffect } from "react";
import "tailwindcss/tailwind.css";

const bstOperations = {
  insert: [
    "function insert(node, value) {",
    "    if (node == null) {",
    "        return newNode(value);",
    "    }",
    "    if (value < node.value) {",
    "        node.left = insert(node.left, value);",
    "    } else if (value > node.value) {",
    "        node.right = insert(node.right, value);",
    "    }",
    "    return node;",
    "}",
  ],
  delete: [
    "function deleteNode(node, value) {",
    "    if (node == null) return null;",
    "    if (value < node.value) {",
    "        node.left = deleteNode(node.left, value);",
    "    } else if (value > node.value) {",
    "        node.right = deleteNode(node.right, value);",
    "    } else {",
    "        if (node.left == null) return node.right;",
    "        if (node.right == null) return node.left;",
    "        let minNode = findMin(node.right);",
    "        node.value = minNode.value;",
    "        node.right = deleteNode(node.right, minNode.value);",
    "    }",
    "    return node;",
    "}",
    "",
    "function findMin(node) {",
    "    while (node.left != null) {",
    "        node = node.left;",
    "    }",
    "    return node;",
    "}"
  ]
};

const initialTree = {
  value: 50,
  left: { value: 30, left: { value: 20, left: null, right: null }, right: { value: 40, left: null, right: null } },
  right: { value: 70, left: { value: 60, left: null, right: null }, right: { value: 80, left: null, right: null } }
};

const TreeLine = ({ x1, y1, x2, y2 }) => (
  <line x1={x1} y1={y1} x2={x2} y2={y2} stroke="#000" strokeWidth="2" />
);

const TreeNode = ({ value, isHighlighted, isTraversed }) => (
  <g>
    <circle 
      r="20" 
      fill={isHighlighted ? "#ff4444" : isTraversed ? "#ffeb3b" : "#3498db"} 
      stroke="#000" 
      strokeWidth="4" 
    />
    <text 
      fill="white" 
      textAnchor="middle" 
      dominantBaseline="central" 
      fontSize="14" 
      fontWeight="bold"
    >
      {value}
    </text>
  </g>
);

const BSTApp = () => {
  const [tree, setTree] = useState(initialTree);
  const [currentNode, setCurrentNode] = useState(null);
  const [traversedNodes, setTraversedNodes] = useState(new Set());
  const [inputValue, setInputValue] = useState("");
  const [operation, setOperation] = useState("insert");
  const [currentLine, setCurrentLine] = useState(-1);
  const [explanation, setExplanation] = useState("Enter a value and select an operation");
  const [isExecuting, setIsExecuting] = useState(false);

  const calculateNodePosition = (node, x, y, level, width) => {
    if (!node) return null;
    const newWidth = width / 2;
    const yOffset = 80;
    const leftChild = calculateNodePosition(node.left, x - newWidth, y + yOffset, level + 1, newWidth);
    const rightChild = calculateNodePosition(node.right, x + newWidth, y + yOffset, level + 1, newWidth);
    return { ...node, x, y, children: { left: leftChild, right: rightChild } };
  };

  const renderConnections = (node) => {
    if (!node) return null;
    const connections = [];
    if (node.children.left) {
      connections.push(
        <TreeLine 
          key={`${node.value}-${node.children.left.value}`} 
          x1={node.x} 
          y1={node.y} 
          x2={node.children.left.x} 
          y2={node.children.left.y} 
        />
      );
    }
    if (node.children.right) {
      connections.push(
        <TreeLine 
          key={`${node.value}-${node.children.right.value}`} 
          x1={node.x} 
          y1={node.y} 
          x2={node.children.right.x} 
          y2={node.children.right.y} 
        />
      );
    }
    return [
      ...connections,
      node.children.left && renderConnections(node.children.left),
      node.children.right && renderConnections(node.children.right)
    ];
  };

  const renderNodes = (node) => {
    if (!node) return null;
    return (
      <>
        <g transform={`translate(${node.x},${node.y})`}>
          <TreeNode 
            value={node.value} 
            isHighlighted={currentNode && currentNode.value === node.value}
            isTraversed={traversedNodes.has(node.value)}
          />
        </g>
        {node.children.left && renderNodes(node.children.left)}
        {node.children.right && renderNodes(node.children.right)}
      </>
    );
  };

  const insertNode = (node, value) => {
    if (node == null) {
      return { value, left: null, right: null };
    }
    if (value < node.value) {
      return { ...node, left: insertNode(node.left, value) };
    } else if (value > node.value) {
      return { ...node, right: insertNode(node.right, value) };
    }
    return node;
  };

  const findMin = (node) => {
    while (node.left != null) {
      node = node.left;
    }
    return node;
  };

  const deleteNode = (node, value) => {
    if (node == null) return null;
    if (value < node.value) {
      return { ...node, left: deleteNode(node.left, value) };
    } else if (value > node.value) {
      return { ...node, right: deleteNode(node.right, value) };
    } else {
      if (node.left == null) return node.right;
      if (node.right == null) return node.left;
      const minNode = findMin(node.right);
      return {
        ...node,
        value: minNode.value,
        right: deleteNode(node.right, minNode.value)
      };
    }
  };

  const executeStep = async () => {
    if (!isExecuting) return;

    const value = parseInt(inputValue);
    if (!currentNode) {
      setCurrentNode(tree);
      setTraversedNodes(new Set());
      setCurrentLine(0);
      return;
    }

    setTraversedNodes(prev => new Set([...prev, currentNode.value]));

    if (operation === "insert") {
      if (value < currentNode.value) {
        if (currentNode.left === null) {
          setExplanation(`Inserting ${value} to the left of ${currentNode.value}`);
          setTree(prevTree => insertNode(prevTree, value));
          setIsExecuting(false);
          setCurrentNode(null);
        } else {
          setExplanation(`Traversing left from ${currentNode.value}`);
          setCurrentNode(currentNode.left);
        }
      } else if (value > currentNode.value) {
        if (currentNode.right === null) {
          setExplanation(`Inserting ${value} to the right of ${currentNode.value}`);
          setTree(prevTree => insertNode(prevTree, value));
          setIsExecuting(false);
          setCurrentNode(null);
        } else {
          setExplanation(`Traversing right from ${currentNode.value}`);
          setCurrentNode(currentNode.right);
        }
      } else {
        setExplanation(`${value} already exists in the tree`);
        setIsExecuting(false);
        setCurrentNode(null);
      }
    } else if (operation === "delete") {
      if (value < currentNode.value) {
        if (currentNode.left === null) {
          setExplanation(`${value} not found in the tree`);
          setIsExecuting(false);
          setCurrentNode(null);
        } else {
          setExplanation(`Traversing left from ${currentNode.value}`);
          setCurrentNode(currentNode.left);
        }
      } else if (value > currentNode.value) {
        if (currentNode.right === null) {
          setExplanation(`${value} not found in the tree`);
          setIsExecuting(false);
          setCurrentNode(null);
        } else {
          setExplanation(`Traversing right from ${currentNode.value}`);
          setCurrentNode(currentNode.right);
        }
      } else {
        setExplanation(`Deleting ${value}`);
        setTree(prevTree => deleteNode(prevTree, value));
        setIsExecuting(false);
        setCurrentNode(null);
      }
    }

    setCurrentLine(prev => (prev + 1) % bstOperations[operation].length);
  };

  useEffect(() => {
    const timer = setInterval(() => {
      if (isExecuting) {
        executeStep();
      }
    }, 1000);

    return () => clearInterval(timer);
  }, [isExecuting, currentNode]);

  const handleExecute = () => {
    if (!inputValue || isNaN(parseInt(inputValue))) {
      setExplanation("Please enter a valid number");
      return;
    }
    setIsExecuting(true);
  };

  const positionedTree = calculateNodePosition(tree, 300, 50, 0, 300);

return (
    <div className="w-full h-full min-h-screen flex items-center justify-between space-x-4 bg-gray-100 p-4">
      <div className="w-1/2 min-h-[85vh] p-6 bg-white rounded-lg shadow">
        <h1 className="text-2xl font-bold mb-4">Binary Search Tree Visualization</h1>
        <div className="flex items-center space-x-4 mb-6">
          <input
            type="number"
            value={inputValue}
            onChange={(e) => setInputValue(e.target.value)}
            className="w-32 p-2 border rounded focus:ring-2 focus:ring-blue-500"
            placeholder="Enter value"
          />
          <select
            value={operation}
            onChange={(e) => setOperation(e.target.value)}
            className="p-2 border rounded focus:ring-2 focus:ring-blue-500"
          >
            <option value="insert">Insert</option>
            <option value="delete">Delete</option>
          </select>
          <button
            onClick={handleExecute}
            disabled={isExecuting}
            className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 disabled:opacity-50"
          >
            Execute
          </button>
        </div>
        <p className="text-gray-600 mb-4">{explanation}</p>
        <div className="w-full overflow-hidden">
          <svg 
            width="600" 
            height="400" 
            className="w-full bg-white rounded-lg"
            viewBox="0 0 600 400"
            preserveAspectRatio="xMidYMid meet"
          >
            {positionedTree && (
              <>
                {renderConnections(positionedTree)}
                {renderNodes(positionedTree)}
              </>
            )}
          </svg>
        </div>
      </div>
      <div className="w-1/2 min-h-[85vh] p-6 bg-white rounded-lg shadow">
        <h1 className="text-2xl font-bold mb-4">
          BST {operation.charAt(0).toUpperCase() + operation.slice(1)} Algorithm
        </h1>
        <div className="bg-gray-50 p-4 rounded-lg overflow-auto">
          {bstOperations[operation].map((line, index) => (
            <div
              key={index}
              className={`font-mono p-2 ${
                currentLine === index ? 'bg-yellow-200' : ''
              }`}
            >
              {line}
            </div>
          ))}
        </div>
      </div>
    </div>
  );
};

export default BSTApp;